use chrono::{DateTime, TimeZone, Utc};
use sha1::{Digest, Sha1};
use std;
use std::fmt;

#[derive(Debug)]
pub struct Entry {
    pub c_time: DateTime<Utc>,
    pub m_time: DateTime<Utc>,
    pub dev: u32,
    pub inode: u32,
    pub mode: u32,
    pub uid: u32,
    pub gid: u32,
    pub size: u32,
    pub hash: Vec<u8>,
    pub name: String,
}

#[derive(Debug)]
pub struct Index {
    pub entries: Vec<Entry>,
}

impl Entry {
    pub fn new(
        c_time: DateTime<Utc>,
        m_time: DateTime<Utc>,
        dev: u32,
        inode: u32,
        mode: u32,
        uid: u32,
        gid: u32,
        size: u32,
        hash: Vec<u8>,
        name: String,
    ) -> Self {
        Self {
            c_time,
            m_time,
            dev,
            inode,
            mode,
            uid,
            gid,
            size,
            hash,
            name,
        }
    }

    pub fn from(bytes: &[u8]) -> Option<Self> {
        let c_time = hex_to_num(&bytes[0..4]);
        let c_time_nano = hex_to_num(&bytes[4..8]);
        let m_time = hex_to_num(&bytes[8..12]);
        let m_time_nano = hex_to_num(&bytes[12..16]);
        let dev = hex_to_num(&bytes[16..20]);
        let inode = hex_to_num(&bytes[20..24]);
        let mode = hex_to_num(&bytes[24..28]);
        let uid = hex_to_num(&bytes[28..32]);
        let gid = hex_to_num(&bytes[32..36]);
        let size = hex_to_num(&bytes[36..40]);
        let hash = Vec::from(&bytes[40..60]);
        let name_size = hex_to_num(&bytes[60..62]);
        let name = String::from_utf8(Vec::from(&bytes[62..(62 + name_size as usize)])).ok()?;

        let entry = Self {
            c_time: Utc.timestamp(c_time.into(), c_time_nano),
            m_time: Utc.timestamp(m_time.into(), m_time_nano),
            dev,
            inode,
            mode,
            uid,
            gid,
            size,
            hash,
            name,
        };

        Some(entry)
    }

    pub fn as_bytes(&self) -> Vec<u8> {
        let ctime = self.c_time.timestamp() as u32;
        let ctime_nano = self.c_time.timestamp_subsec_nanos();
        let mtime = self.m_time.timestamp() as u32;
        let mtime_nano = self.m_time.timestamp_subsec_nanos();

        let meta = [
            ctime, ctime_nano, mtime, mtime_nano, self.dev, self.inode, self.mode, self.uid,
            self.gid, self.size,
        ]
        .iter()
        .flat_map(|&x| Vec::from(x.to_be_bytes()))
        .collect::<Vec<_>>();

        let name_size = self.name.len() as u16;
        let name = self.name.as_bytes();

        let len = 62 + name_size as usize;

        let padding = (0..(8 - len % 8)).map(|_| b'\0').collect::<Vec<u8>>();

        [
            meta,
            self.hash.clone(),
            Vec::from(name_size.to_be_bytes()),
            name.to_vec(),
            padding,
        ]
        .concat()
    }

    pub fn size(&self) -> usize {
        let size = 62 + self.name.len();
        size + (8 - size % 8)
    }
}

impl fmt::Display for Entry {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{} {} 0\t{}",
            num_to_mode(self.mode as u16),
            hex::encode(&self.hash),
            self.name
        )
    }
}

impl Index {
    pub fn new(entries: Vec<Entry>) -> Self {
        Self { entries }
    }

    pub fn from(bytes: &[u8]) -> Option<Self> {
        // インデックスファイルじゃない
        if &bytes[0..4] != b"DIRC" {
            return None;
        }

        // バージョン２だけに対応
        if hex_to_num(&bytes[4..8]) != 2 {
            return None;
        }

        let entry_num = hex_to_num(&bytes[8..12]);
        let entries = (0..entry_num)
            .try_fold((0, Vec::new()), |(offs, mut vec), _| {
                let entry = Entry::from(&bytes[(12 + offs)..])?;
                let size = entry.size();
                vec.push(entry);
                Some((offs + size, vec))
            })
            .map(|(_, entries)| entries)?;

        Some(Self::new(entries))
    }

    pub fn as_bytes(&self) -> Vec<u8> {
        let header = [
            *b"DIRC",
            [0x00, 0x00, 0x00, 0x02],
            (self.entries.len() as u32).to_be_bytes(),
        ]
        .concat();

        let entries = self
            .entries
            .iter()
            .flat_map(|x| x.as_bytes())
            .collect::<Vec<_>>();

        let content = [header, entries].concat();
        let hash = Vec::from(Sha1::digest(&content).as_slice());

        [content, hash].concat()
    }
}

impl fmt::Display for Index {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.entries.iter().try_for_each(|e| write!(f, "{}\n", e))
    }
}

fn hex_to_num(hex: &[u8]) -> u32 {
    hex.iter()
        .rev()
        .fold((0u32, 1u32), |(sum, offs), &x| {
            (sum + (x as u32 * offs), offs << 8)
        })
        .0
}

fn num_to_mode(val: u16) -> String {
    let file_type = val >> 13;
    let (user, group, other) = {
        let permission = val & 0x01ff;
        let user = (permission & 0x01c0) >> 6;
        let group = (permission & 0x0038) >> 3;
        let other = permission & 0x0007;

        (user, group, other)
    };

    format!("{:03b}{}{}{}", file_type, user, group, other)
}

#[test]
fn test_hex_to_num() {
    let expected = hex_to_num(&[0x00, 0x00, 0x02, 0x62]);
    assert_eq!(expected, 0x0262);
}

#[test]
fn test_entry_from() {
    let bytes = [
        0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01, 0xd8, 0xd8, 0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01, 0xd8,
        0xd8, 0x01, 0x00, 0x00, 0x04, 0x01, 0x9c, 0xd3, 0x5c, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
        0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x9d, 0xe2, 0x9b, 0xb2,
        0xd1, 0xd6, 0x43, 0x4b, 0x8b, 0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2, 0xe4, 0x8c, 0x53, 0x91,
        0x00, 0x1b, 0x68, 0x6f, 0x67, 0x65, 0x2f, 0x68, 0x75, 0x67, 0x61, 0x2f, 0x62, 0x61, 0x72,
        0x2f, 0x70, 0x69, 0x79, 0x6f, 0x2f, 0x2e, 0x67, 0x69, 0x74, 0x6b, 0x65, 0x65, 0x70, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    let expected = Entry::from(&bytes);
    if let Some(entry) = expected {
        assert_eq!(entry.size(), 96);
        assert!(true);
    } else {
        assert!(false);
    }
}

#[test]
fn test_index_from() {
    let bytes = [
        0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x5f, 0x4a, 0x42,
        0x31, 0x07, 0x0c, 0xb5, 0x6a, 0x5f, 0x4a, 0x42, 0x31, 0x07, 0x0c, 0xb5, 0x6a, 0x01, 0x00,
        0x00, 0x04, 0x01, 0x8f, 0xe1, 0xbd, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00,
        0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x13, 0x96, 0xef, 0x6c, 0x0b, 0x94, 0x4e, 0x24, 0xfc,
        0x22, 0xf5, 0x1f, 0x18, 0x13, 0x6c, 0xd6, 0x2f, 0xfd, 0x5b, 0x0b, 0x8f, 0x00, 0x0a, 0x2e,
        0x67, 0x69, 0x74, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x5f, 0x53, 0x1c, 0xf0, 0x32, 0x72, 0x44, 0x06, 0x5f, 0x53, 0x1c, 0xf0, 0x32,
        0x72, 0x44, 0x06, 0x01, 0x00, 0x00, 0x04, 0x01, 0x92, 0x0d, 0xc7, 0x00, 0x00, 0x81, 0xa4,
        0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x01, 0x5e, 0xf7, 0xa9, 0xac,
        0x08, 0xc2, 0x97, 0x50, 0xad, 0x7b, 0x6f, 0xe6, 0x96, 0xed, 0x28, 0x8b, 0x62, 0x34, 0x41,
        0xfd, 0xbc, 0x00, 0x0a, 0x43, 0x61, 0x72, 0x67, 0x6f, 0x2e, 0x74, 0x6f, 0x6d, 0x6c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x50, 0x4f, 0xac, 0x22, 0x80, 0x54, 0x35,
        0x5f, 0x50, 0x4f, 0xac, 0x22, 0x80, 0x54, 0x35, 0x01, 0x00, 0x00, 0x04, 0x01, 0x99, 0x1a,
        0x71, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
        0x00, 0x09, 0x11, 0xb4, 0x81, 0xfc, 0x1b, 0x15, 0xa5, 0x9c, 0x2b, 0x55, 0x83, 0x02, 0x5d,
        0x09, 0x8e, 0x11, 0x8b, 0x90, 0xe1, 0x2e, 0x00, 0x09, 0x52, 0x45, 0x41, 0x44, 0x4d, 0x45,
        0x2e, 0x6d, 0x64, 0x00, 0x5f, 0x55, 0x7c, 0xfd, 0x11, 0xc3, 0x75, 0x61, 0x5f, 0x55, 0x7c,
        0xfd, 0x11, 0xc3, 0x75, 0x61, 0x01, 0x00, 0x00, 0x04, 0x01, 0x9a, 0x04, 0x12, 0x00, 0x00,
        0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x25, 0x24, 0x97,
        0x04, 0x99, 0x02, 0xe3, 0xf4, 0x4c, 0x0e, 0xd5, 0xc4, 0xe1, 0xd7, 0xa2, 0x69, 0xf0, 0x42,
        0x56, 0xce, 0xcc, 0x51, 0x00, 0x10, 0x73, 0x72, 0x63, 0x2f, 0x69, 0x6e, 0x64, 0x65, 0x78,
        0x2f, 0x6d, 0x6f, 0x64, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x5f, 0x52, 0xee, 0x27, 0x1e, 0x41,
        0x92, 0x4a, 0x5f, 0x52, 0xee, 0x27, 0x1e, 0x41, 0x92, 0x4a, 0x01, 0x00, 0x00, 0x04, 0x01,
        0x8f, 0xe1, 0xc0, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14,
        0x00, 0x00, 0x03, 0xa1, 0xb2, 0x98, 0x40, 0xf6, 0x70, 0xca, 0x7a, 0x8b, 0x1a, 0xfb, 0x5f,
        0x6e, 0x9b, 0x23, 0x88, 0x98, 0x07, 0xb4, 0x81, 0x26, 0x00, 0x0a, 0x73, 0x72, 0x63, 0x2f,
        0x6c, 0x69, 0x62, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f,
        0x54, 0x90, 0xb0, 0x10, 0xf6, 0x2a, 0xc0, 0x5f, 0x54, 0x90, 0xb0, 0x10, 0xf6, 0x2a, 0xc0,
        0x01, 0x00, 0x00, 0x04, 0x01, 0x90, 0x09, 0xa3, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01,
        0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x05, 0xe3, 0x66, 0x67, 0xdb, 0xbb, 0xdf, 0x59,
        0x23, 0x08, 0x81, 0x4e, 0x83, 0x65, 0x14, 0xeb, 0xf6, 0x6d, 0x03, 0x58, 0xb3, 0x21, 0x00,
        0x0b, 0x73, 0x72, 0x63, 0x2f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x5f, 0x4e, 0xbd, 0x71, 0x24, 0xc8, 0xb3, 0x69, 0x5f, 0x4e, 0xbd,
        0x71, 0x24, 0xc8, 0xb3, 0x69, 0x01, 0x00, 0x00, 0x04, 0x01, 0x92, 0x6b, 0xf1, 0x00, 0x00,
        0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x03, 0xb8, 0x3e,
        0x31, 0xbc, 0x74, 0xba, 0x52, 0x26, 0xd5, 0xf2, 0x74, 0xb5, 0x09, 0xe3, 0x09, 0xa4, 0x6c,
        0x55, 0x15, 0x35, 0x95, 0x00, 0x12, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65, 0x63,
        0x74, 0x2f, 0x62, 0x6c, 0x6f, 0x62, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x5f, 0x50, 0x82, 0xed, 0x20, 0xa8, 0xe1, 0xb8, 0x5f, 0x50, 0x82, 0xed, 0x20,
        0xa8, 0xe1, 0xb8, 0x01, 0x00, 0x00, 0x04, 0x01, 0x95, 0x70, 0x0d, 0x00, 0x00, 0x81, 0xa4,
        0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x13, 0xdf, 0xf6, 0x77, 0xcb,
        0xc7, 0x39, 0xcb, 0x92, 0x36, 0xee, 0x69, 0x77, 0xdd, 0x11, 0x0b, 0x19, 0x97, 0x16, 0xae,
        0x80, 0x5d, 0x00, 0x14, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2f,
        0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x5f, 0x50, 0x7c, 0xa6, 0x2f, 0xfe, 0xf2, 0x7a, 0x5f, 0x50, 0x7c, 0xa6, 0x2f, 0xfe, 0xf2,
        0x7a, 0x01, 0x00, 0x00, 0x04, 0x01, 0x92, 0x6b, 0xed, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
        0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x05, 0x86, 0xfd, 0xac, 0x7b, 0x8b, 0xd5,
        0x3e, 0x80, 0xc0, 0x95, 0x64, 0x49, 0xf5, 0xc9, 0xda, 0x13, 0xea, 0x7c, 0xb1, 0x53, 0x9c,
        0x00, 0x11, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2f, 0x6d, 0x6f,
        0x64, 0x2e, 0x72, 0x73, 0x00, 0x5f, 0x4e, 0xe6, 0x2d, 0x16, 0xa9, 0x8b, 0x26, 0x5f, 0x4e,
        0xe6, 0x2d, 0x16, 0xa9, 0x8b, 0x26, 0x01, 0x00, 0x00, 0x04, 0x01, 0x93, 0x74, 0x33, 0x00,
        0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x0a, 0x1e,
        0xda, 0x8b, 0x2d, 0xb1, 0xdd, 0xa2, 0x7e, 0x83, 0x41, 0x5d, 0x64, 0x38, 0x84, 0x81, 0x13,
        0x12, 0xcd, 0x17, 0x75, 0xb9, 0x00, 0x12, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65,
        0x63, 0x74, 0x2f, 0x74, 0x72, 0x65, 0x65, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x54, 0x52, 0x45, 0x45, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x2d, 0x31, 0x20,
        0x31, 0x0a, 0x73, 0x72, 0x63, 0x00, 0x2d, 0x31, 0x20, 0x31, 0x0a, 0x6f, 0x62, 0x6a, 0x65,
        0x63, 0x74, 0x00, 0x2d, 0x31, 0x20, 0x30, 0x0a, 0x01, 0xd4, 0xa6, 0x28, 0xcc, 0xab, 0x7a,
        0x38, 0x71, 0x5e, 0x9e, 0x22, 0x0b, 0x17, 0xc8, 0x89, 0xe0, 0x63, 0xdd, 0x3b,
    ];

    let index = Index::from(&bytes);
    if let Some(i) = index {
        assert_eq!(i.entries.len(), 10);
    } else {
        assert!(false);
    }
}

#[test]
fn test_num_to_mode() {
    let val = num_to_mode(33188);
    assert_eq!(val, String::from("100644"));
}

#[test]
fn test_entry_as_bytes() {
    let bytes = [
        0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01, 0xd8, 0xd8, 0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01, 0xd8,
        0xd8, 0x01, 0x00, 0x00, 0x04, 0x01, 0x9c, 0xd3, 0x5c, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
        0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x9d, 0xe2, 0x9b, 0xb2,
        0xd1, 0xd6, 0x43, 0x4b, 0x8b, 0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2, 0xe4, 0x8c, 0x53, 0x91,
        0x00, 0x1b, 0x68, 0x6f, 0x67, 0x65, 0x2f, 0x68, 0x75, 0x67, 0x61, 0x2f, 0x62, 0x61, 0x72,
        0x2f, 0x70, 0x69, 0x79, 0x6f, 0x2f, 0x2e, 0x67, 0x69, 0x74, 0x6b, 0x65, 0x65, 0x70, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    let entry = Entry::from(&bytes);
    if let Some(e) = entry {
        assert_eq!(e.as_bytes(), Vec::from(&bytes[..]));
    } else {
        assert!(false);
    }
}
